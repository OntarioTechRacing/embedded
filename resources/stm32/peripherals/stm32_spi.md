# STM32 SPI

## What is SPI?

SPI stands for Serial Peripheral Interface. It is commonly used for interfacing with sensors,  
memory devices, and other integrated circuits. It allows for multi-level communication, meaning it
can receive and send data simultaneously. SPI operates in a master-slave architecture where a
master device controls one or multiple slave devices.

It involves four lines of communication:

1. SCK (Serial Clock) - This is the clock signal generated by the master device to synchronize data
   transmission.
2. MOSI (Master Out Slave In) - This line carries data from the master to the slave.
3. MISO (Master In Slave Out) - This line carries data from the slave to the master.
4. NSS (Slave Select/Chip Select) - This line is used to select the specific slave device with
   which the master wants to communicate. When configured as `SPI_NSS_SOFT` the NSS pin is managed
   by the SPI hardware when transmitting or receiving data. When a master device sends data, the
   NSS pin is automatically enabled (set low) and then disabled (set high) after the data transfer
   is completed.

## What's the difference between SPI and UART?

UART is a communication protocol that can operate in both synchronous and asynchronous modes. It is
capable of handling both serial and parallel data transmissions. SPI is a synchronous protocol
specifically designed for serial communication between microcontrollers and peripheral devices.
While both protocols can handle serial communication, SPI is generally faster and more efficient
for communicating with external devices due to its dedicated hardware support for synchronous
communication.

## .ioc Configuration

1. Configure SPI pins (SCK, MOSI, MISO, SS/CS), appropriate mode, data size and other parameters.

## Code

1. Variable declaration

   ```C
   /* USER CODE BEGIN 0 */
   
   uint8_t tx_data = 0x55; // Data to be transmitted.
   uint8_t rx_data; // Received data.
   
   /* USER CODE END 0 */
   ```

2. SPI initialization **(Automatically generated by STM32CubeMX)**
    - This is an example for SPI1 on an STM32L432KC on `Full-Duplex Master` mode

   ```C
   /**
   * @brief SPI1 Initialization Function
   * @param None
   * @retval None
   */
   static void MX_SPI1_Init(void)
   {

     /* USER CODE BEGIN SPI1_Init 0 */

     /* USER CODE END SPI1_Init 0 */

     /* USER CODE BEGIN SPI1_Init 1 */

     /* USER CODE END SPI1_Init 1 */
     /* SPI1 parameter configuration*/
     hspi1.Instance = SPI1;
     hspi1.Init.Mode = SPI_MODE_MASTER;
     hspi1.Init.Direction = SPI_DIRECTION_2LINES;
     hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
     hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
     hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
     hspi1.Init.NSS = SPI_NSS_SOFT;
     hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
     hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
     hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
     hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
     hspi1.Init.CRCPolynomial = 7;
     hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
     hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
     if (HAL_SPI_Init(&hspi1) != HAL_OK)
     {
       Error_Handler();
     }
     /* USER CODE BEGIN SPI1_Init 2 */

     /* USER CODE END SPI1_Init 2 */

   }
   ```

3. SPI Transfer

   ```C
   // Select the slave device (if using hardware SS/CS pin, this step might not be needed).
   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET); // Assuming GPIOA Pin 4 is used as SS/CS.
   
   // Transmit data.
   HAL_SPI_Transmit(&hspi, &tx_data, 1, HAL_MAX_DELAY);
   
   // Receive data.
   HAL_SPI_Receive(&hspi, &rx_data, 1, HAL_MAX_DELAY);
   
   // Deselect the slave device.
   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
   
   // Process received data (use rx_data variable).
   ``` 
