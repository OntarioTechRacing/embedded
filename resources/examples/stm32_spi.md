# STM32 SPI

## What is SPI ?

SPI stands for Serial Peripheral Interface. It is commonly used for interfacing with sensors, memory devices, and other
integrated circuits. It allows for multi-level communication, meaning it can receive and send data simultaneously. 
SPI operates in a master-slave architecture where a master device controls one or multiple slave devices. 

It involves four lines of communication:

1. SCK (Serial Clock) - This is the clock signal generated by the master device to synchronize data transmission.
2. MOSI (Master Out Slave In) - This line carries data from the master to the slave.
3. MISO (Master In Slave Out) - This line carries data from the slave to the master.
4. NSS (Slave Select/Chip Select) - This line is used to select the specific slave device with which the master wants to communicate. When
configured as `SPI_NSS_SOFT` the NSS pin is managed by the SPI hardware when transmitting or recieving data.
When a master device sends data, the NSS pin is automatically enabled (set low) and then disabled (set high) after the data transfer
is completed. 

## What's the difference between SPI and USART ?

USART is a communication protocol that can operate in both synchronous and asynchronous modes. It is capable of handling both 
serial and parallel data transmissions. SPI is a synchronous protocol specifically designed for serial communication between 
microcontrollers and peripheral devices. While both protocols can handle serial communication, SPI is generally faster and more
efficient for communicating with external devices due to its dedicated hardware support for synchronous communication.

## `.ioc` Configuration

1. Configure SPI pins (SCK, MOSI, MISO, SS/CS), appropriate mode, data size and other parameters. 
  
## Code

1. Variable Declaration

    ```C
     /* USER CODE BEGIN 0 */
  
    uint8_t tx_data = 0x55; // Data to be transmitted
    uint8_t rx_data; // Received data
  
    /* USER CODE END 0 */
     ```

2. SPI Initialization

     ```C
     /* USER CODE BEGIN 1 */
     
    // SPI initialization
    hspi.Instance = SPI1; // SPI1 or SPI2, etc., based on your hardware configuration
    hspi.Init.Mode = SPI_MODE_MASTER;
    hspi.Init.Direction = SPI_DIRECTION_2LINES;
    hspi.Init.DataSize = SPI_DATASIZE_8BIT;
    hspi.Init.CLKPolarity = SPI_POLARITY_LOW;
    hspi.Init.CLKPhase = SPI_PHASE_1EDGE;
    hspi.Init.NSS = SPI_NSS_SOFT; // or SPI_NSS_HARD_OUTPUT, based on your setup
    hspi.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256; // Adjust as needed for your setup
    hspi.Init.FirstBit = SPI_FIRSTBIT_MSB;
    hspi.Init.TIMode = SPI_TIMODE_DISABLE;
    hspi.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
    hspi.Init.CRCPolynomial = 10;
    HAL_SPI_Init(&hspi);
     
    /* USER CODE END 1 */
     ```

3. SPI Transfer

   ```C
    /* USER CODE BEGIN 2 */
   
    // Select the slave device (if using hardware SS/CS pin, this step might not be needed)
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET); // Assuming GPIOA Pin 4 is used as SS/CS
    
    // Transmit data
    HAL_SPI_Transmit(&hspi, &tx_data, 1, HAL_MAX_DELAY);
    
    // Receive data
    HAL_SPI_Receive(&hspi, &rx_data, 1, HAL_MAX_DELAY);
    
    // Deselect the slave device
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
    
    // Process received data (use rx_data variable)
   
    /* USER CODE END 2 */
   ``` 
